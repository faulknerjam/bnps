<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="James Faulkner" />


<title>Using spmrf for Phylodynamic Inference</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Using <code>spmrf</code> for Phylodynamic Inference</h1>
<h4 class="author"><em>James Faulkner</em></h4>



<p>The following document provides <code>R</code> code for fitting shrinkage prior Markov random field models using the <code>spmrf</code> package applied to coalescent time data for phylodynamic inference of effective population size trajectories, as described in Faulkner et al. (2018). See the <a href="introduction_to_spmrf.html">Introduction to the spmrf package</a> for instructions on installation and more details about the package. Note that the <code>spmrf</code> function only operates on coalescent time data and cannot be used directly on sequence data nor to infer parameters for trait evolution models.</p>
<div id="install-necessary-packages" class="section level2">
<h2>Install Necessary Packages</h2>
<p>Make sure you have <code>spmrf</code> and <code>rstan</code> installed, then load the libraries.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(spmrf)
<span class="kw">library</span>(rstan)</code></pre></div>
</div>
<div id="simulated-data-example" class="section level2">
<h2>Simulated Data Example</h2>
<p>We will start with a set of simulated coalescent data generated from a scenario used in Faulkner et al. (2018). This example represents an extreme bottleneck in effective population size. First we simulate the coalescent data given the specified population trajectory, set up the grid over which we will estimate effective population size, and create the data list for input to <code>spmrf</code>. Note that the effective population sizes are very small and that is only done to decrease the coalescent times to make the time scale more compact.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Generate simulated data</span>
nsamp &lt;-<span class="st"> </span><span class="dv">500</span>   <span class="co">#number of samples total</span>
nstart &lt;-<span class="st"> </span><span class="dv">50</span>   <span class="co">#number of samples at time zero</span>
nbndry &lt;-<span class="st"> </span><span class="dv">101</span>  <span class="co">#number of grid cell boundaries (number of cells plus 1)</span>
samp.end &lt;-<span class="st"> </span><span class="dv">8</span>  <span class="co">#last potential sample time</span>
samptv &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="kw">sort</span>(<span class="kw">runif</span>(nsamp-nstart, <span class="dv">0</span>, samp.end)) ) <span class="co">#vector of sample times</span>
nsampv &lt;-<span class="st"> </span><span class="kw">c</span>(nstart, <span class="kw">rep</span>(<span class="dv">1</span>, nsamp-nstart))  <span class="co">#vector of number sampled</span>
<span class="co"># simulate coalescent times</span>
coaldat &lt;-<span class="st"> </span><span class="kw">coaltimeSim</span>(<span class="dt">samp_times =</span> samptv, <span class="dt">n_sampled =</span> nsampv, 
            <span class="dt">traj =</span> bottleNeck_traj, <span class="dt">lower_bound =</span> <span class="fl">0.1</span>, <span class="dt">ne.max=</span><span class="dv">1</span>, <span class="dt">ne.min=</span><span class="fl">0.1</span>, <span class="dt">bstart=</span><span class="dv">6</span>, <span class="dt">bend=</span><span class="dv">4</span>  )

<span class="co"># Calculate a grid for estimation</span>
sgrid &lt;-<span class="st"> </span><span class="kw">makeGrid</span>(<span class="dt">coal_times =</span> coaldat$coal_times, <span class="dt">samp_times =</span> samptv, <span class="dt">Ngrid=</span>nbndry)

<span class="co"># Make data set for input to spmrf</span>
cdat &lt;-<span class="st">  </span><span class="kw">make_coalescent_data</span>(<span class="dt">samp_times =</span> samptv, <span class="dt">n_sampled =</span> nsampv, <span class="dt">coal_times =</span> coaldat$coal_times, <span class="dt">grid =</span> sgrid$grid)</code></pre></div>
<p>We can take a look at what the population trajectory looks like by plotting it over the midpoints of the grid. Note that we reverse the coordinates of the x-axis so that we go backwards in time from the present.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Calculate trajectory over the grid</span>
truetraj &lt;-<span class="st"> </span><span class="kw">bottleNeck_traj</span>(<span class="dt">t =</span> sgrid$midpts, <span class="dt">lower_bound =</span> <span class="fl">0.1</span>, <span class="dt">ne.max=</span><span class="dv">1</span>, <span class="dt">ne.min=</span><span class="fl">0.1</span>, <span class="dt">bstart=</span><span class="dv">6</span>, <span class="dt">bend=</span><span class="dv">4</span>)

<span class="co"># Plot</span>
<span class="kw">plot</span>(sgrid$midpts, truetraj, <span class="dt">xlim=</span><span class="kw">range</span>(<span class="kw">rev</span>(sgrid$midpts)), <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">1.2</span>), <span class="dt">type=</span><span class="st">&quot;l&quot;</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>,
     <span class="dt">xlab=</span><span class="st">&quot;Time before present&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;Effective population size&quot;</span>)</code></pre></div>
<p>Next we will fit the model using two different priors for the effective population size. The first prior is the standard Gaussian Markov random field (GMRF) and the second is the horseshoe Markov random field (HSMRF). The first step is to calculate a reasonable value for the hyperparameter <code>zeta</code>, which controls the scale of the half-Cauchy prior that controls the global level of smoothing in the models. We will use the same value of <code>zeta</code> for both models. We then set up the MCMC settings and run the models. Note that once <code>spmrf</code> builds the model code and calls stan, the model code gets transfered to C++ and compiled. This process takes about 30 seconds for each model. For the GMRF model, once the code compilation was complete, each chain took approximately 45 seconds to run on my machine, for a total run time of about 4 minutes. For the HSMRF model, each chain took about 2-3 minutes to run, for a total run time of about 12 minutes. Once the sampling is complete for each model, we then capture the posterior samples and get posterior summariies for the effective population size parameters.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Set hyperparameter for global scale</span>
zeta &lt;-<span class="st"> </span><span class="kw">set_zeta_phylo</span>(<span class="dt">phylo =</span> coaldat, <span class="dt">ncell =</span> <span class="dv">100</span>, <span class="dt">alpha =</span> <span class="fl">0.05</span>, <span class="dt">order =</span> <span class="dv">1</span>)

<span class="co"># Parameters to keep </span>
pars.G &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;theta&quot;</span>, <span class="st">&quot;gam&quot;</span>) 
pars.H &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;theta&quot;</span>, <span class="st">&quot;tau&quot;</span>, <span class="st">&quot;gam&quot;</span>) 

<span class="co"># MCMC settings</span>
nchain &lt;-<span class="st"> </span><span class="dv">4</span>    <span class="co">#number of chains</span>
ntotsamp &lt;-<span class="st"> </span><span class="dv">2000</span>  <span class="co">#total number of samples to keep across all chains</span>
nthin &lt;-<span class="st"> </span><span class="dv">2</span>        <span class="co">#thinning level</span>
nburn &lt;-<span class="st"> </span><span class="dv">1000</span>     <span class="co">#warm-up / burn-in iterations per chain</span>
niter &lt;-<span class="st"> </span>(ntotsamp/nchain)*nthin +<span class="st"> </span>nburn  <span class="co">#total iterations to run</span>

<span class="co"># Run models</span>
fit.G &lt;-<span class="st"> </span><span class="kw">spmrf</span>(<span class="dt">prior=</span><span class="st">&quot;normal&quot;</span>, <span class="dt">likelihood=</span><span class="st">&quot;coalescent&quot;</span>, <span class="dt">order=</span><span class="dv">1</span>, <span class="dt">data=</span>cdat, <span class="dt">par=</span>pars.G, 
                    <span class="dt">chains=</span>nchain, <span class="dt">warmup=</span>nburn, <span class="dt">thin=</span>nthin, <span class="dt">iter=</span>niter, <span class="dt">control=</span><span class="kw">list</span>(<span class="dt">adapt_delta=</span><span class="fl">0.98</span>, <span class="dt">max_treedepth=</span><span class="dv">12</span>), <span class="dt">zeta=</span>zeta)
fit.H &lt;-<span class="st"> </span><span class="kw">spmrf</span>(<span class="dt">prior=</span><span class="st">&quot;horseshoe&quot;</span>, <span class="dt">likelihood=</span><span class="st">&quot;coalescent&quot;</span>, <span class="dt">order=</span><span class="dv">1</span>, <span class="dt">data=</span>cdat, <span class="dt">par=</span>pars.H, 
                    <span class="dt">chains=</span>nchain, <span class="dt">warmup=</span>nburn, <span class="dt">thin=</span>nthin, <span class="dt">iter=</span>niter, <span class="dt">control=</span><span class="kw">list</span>(<span class="dt">adapt_delta=</span><span class="fl">0.98</span>, <span class="dt">max_treedepth=</span><span class="dv">12</span>), <span class="dt">zeta=</span>zeta)

<span class="co"># Extract posterior draws</span>
pout.G &lt;-<span class="st"> </span><span class="kw">as.array</span>(fit.G)
pout.H &lt;-<span class="st"> </span><span class="kw">as.array</span>(fit.H)

<span class="co"># Get posterior summary for theta</span>
th.G &lt;-<span class="st"> </span><span class="kw">extract_theta</span>(fit.G, <span class="dt">obstype=</span><span class="st">&quot;coalescent&quot;</span>)
th.H &lt;-<span class="st"> </span><span class="kw">extract_theta</span>(fit.H, <span class="dt">obstype=</span><span class="st">&quot;coalescent&quot;</span>)</code></pre></div>
<p>Now we will take a look at some diagnostic trace plots.</p>
<p>Finally we will plot the posterior median trajectories and 95% credible intervals for each model and compare them to the true trajectory that generated the data.</p>
</div>
<div id="hepatitis-c-outbreak-in-egypt" class="section level2">
<h2>Hepatitis C Outbreak in Egypt</h2>
<p>This example uses coalescent data from a fixed genealogy estimated from sequence data from Egypt. This is similar to the full analysis done on sequence data in Faulkner et al. (2018).</p>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<p>Faulkner, J.R., A.F. Magee, B. Shapiro, and V.N. Minin. 2018. Locally-adaptive Bayesian nonparametric inference for phylodynamics. arXiv preprint to appear</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
